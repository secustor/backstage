import { Config } from '@backstage/config';
import {
  DeferredEntity,
  EntityProvider,
  EntityProviderConnection,
} from '@backstage/plugin-catalog-node';
import * as uuid from 'uuid';
import { readProviderConfigs } from './readProviderConfigs';
import {
  LoggerService,
  SchedulerService,
  SchedulerServiceTaskRunner,
} from '@backstage/backend-plugin-api';

export type {{providerClass}}Options = {
  /**
   * The logger to use.
   */
  logger: LoggerService;

  /**
   * Scheduler used to schedule refreshes based on
   * the schedule config.
   */
  scheduler: SchedulerService;
};

export class {{providerClass}} implements EntityProvider {
  static fromConfig(
    configRoot: Config,
    options: {{providerClass}}Options,
  ): {{providerClass}}[] {
    return readProviderConfigs(configRoot).map(providerConfig => {
      return new {{providerClass}}({
        id: providerConfig.id,
        target: providerConfig.target,
        logger: options.logger,
        taskRunner: options.scheduler.createScheduledTaskRunner(
          providerConfig.schedule,
        ),
      });
    });
  }

  readonly #id: string;
  readonly #target: string;
  readonly #logger: LoggerService;
  readonly #taskRunner: SchedulerServiceTaskRunner;

  constructor(options: {
    id: string;
    target: string;
    logger: LoggerService;
    taskRunner: SchedulerServiceTaskRunner;
  }) {
    this.#id = options.id;
    this.#target = options.target;
    this.#logger = options.logger;
    this.#taskRunner = options.taskRunner;
  }

  /** {@inheritdoc @backstage/plugin-catalog-node#EntityProvider.getProviderName} */
  getProviderName() {
    return `{{providerClass}}:${this.#id}`;
  }

  /** {@inheritdoc @backstage/plugin-catalog-node#EntityProvider.connect} */
  async connect(connection: EntityProviderConnection) {
    const id = `${this.getProviderName()}:refresh`;

    // Schedule a refresh task to be run periodically
    await this.#taskRunner.run({
      id,
      fn: async () => {
        const logger = this.#logger.child({
          taskId: id,
          taskInstanceId: uuid.v4(),
        });

        try {
          const entities = await this.read({ logger });

          logger.info(`Read ${entities.length} entities`);

          await connection.applyMutation({
            type: 'full',
            entities,
          });
        } catch (error) {
          logger.error(`Refresh failed`, error);
        }
      },
    });
  }

  /**
   * Reads entities to be added to the catalog.
   */
  async read(options: { logger: LoggerService }): Promise<DeferredEntity[]> {
    const { logger } = options;

    logger.info(`Reading entities from ${this.#target}`);

    // TODO: Implement entity reading logic from the target
    const entities: DeferredEntity[] = [];

    return entities;
  }
}
